'use client';

import { toast } from 'sonner';
import { APIErrorCode, APIErrorResponse } from './api-error';

// フロントエンド用エラーハンドラー
export class ClientError extends Error {
  constructor(
    public code: string,
    message: string,
    public statusCode?: number,
    public originalError?: unknown
  ) {
    super(message);
    this.name = 'ClientError';
  }
}

// API エラーレスポンスの型ガード
export function isAPIErrorResponse(data: unknown): data is APIErrorResponse {
  return data && typeof data === 'object' && 'error' in data && 'code' in data;
}

// エラーメッセージのカスタマイズマップ
const ERROR_MESSAGE_MAP: Record<APIErrorCode, string> = {
  [APIErrorCode.VALIDATION_ERROR]: '入力データに問題があります',
  [APIErrorCode.INVALID_INPUT]: '入力形式が正しくありません',
  [APIErrorCode.MISSING_REQUIRED_FIELD]: '必須項目が入力されていません',
  
  [APIErrorCode.AUTHENTICATION_REQUIRED]: 'ログインが必要です',
  [APIErrorCode.INVALID_CREDENTIALS]: 'メールアドレスまたはパスワードが正しくありません',
  [APIErrorCode.TOKEN_EXPIRED]: 'セッションの有効期限が切れています。再度ログインしてください',
  [APIErrorCode.TOKEN_INVALID]: '認証情報が無効です',
  [APIErrorCode.INSUFFICIENT_PERMISSIONS]: 'この操作を実行する権限がありません',
  
  [APIErrorCode.RESOURCE_NOT_FOUND]: 'データが見つかりません',
  [APIErrorCode.USER_NOT_FOUND]: 'ユーザーが見つかりません',
  [APIErrorCode.PRODUCT_NOT_FOUND]: '商品が見つかりません',
  [APIErrorCode.ORDER_NOT_FOUND]: '注文情報が見つかりません',
  
  [APIErrorCode.EMAIL_ALREADY_EXISTS]: 'このメールアドレスは既に使用されています',
  [APIErrorCode.ALREADY_PURCHASED]: 'この商品は既に購入済みです',
  [APIErrorCode.PAYMENT_FAILED]: '決済処理に失敗しました',
  [APIErrorCode.DOWNLOAD_LIMIT_EXCEEDED]: 'ダウンロード制限に達しています',
  
  [APIErrorCode.DATABASE_ERROR]: 'サーバーエラーが発生しました',
  [APIErrorCode.EXTERNAL_SERVICE_ERROR]: '外部サービスで問題が発生しています',
  [APIErrorCode.FILE_UPLOAD_ERROR]: 'ファイルのアップロードに失敗しました',
  [APIErrorCode.RATE_LIMIT_EXCEEDED]: 'リクエストが多すぎます。しばらく時間をおいて再度お試しください',
  
  [APIErrorCode.DEMO_USER_RESTRICTION]: 'デモユーザーはこの機能をご利用できません',
  
  [APIErrorCode.INTERNAL_ERROR]: '予期せぬエラーが発生しました',
};

// エラー処理オプション
export interface ErrorHandlingOptions {
  showToast?: boolean; // トースト通知を表示するか
  logError?: boolean; // コンソールにログを出力するか
  fallbackMessage?: string; // フォールバックメッセージ
  onError?: (error: ClientError) => void; // カスタムエラーハンドラー
  redirectOnAuth?: boolean; // 認証エラー時にリダイレクトするか
}

const DEFAULT_OPTIONS: ErrorHandlingOptions = {
  showToast: true,
  logError: true,
  redirectOnAuth: false,
};

// メインエラーハンドラー
export async function handleClientError(
  error: unknown,
  options: ErrorHandlingOptions = {}
): Promise<ClientError> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  let clientError: ClientError;
  
  // Response オブジェクトの場合
  if (error instanceof Response) {
    try {
      const errorData = await error.json();
      
      if (isAPIErrorResponse(errorData)) {
        const userMessage = ERROR_MESSAGE_MAP[errorData.code] || errorData.error;
        clientError = new ClientError(
          errorData.code,
          userMessage,
          error.status,
          errorData
        );
      } else {
        clientError = new ClientError(
          'HTTP_ERROR',
          `HTTPエラー: ${error.status}`,
          error.status,
          error
        );
      }
    } catch {
      clientError = new ClientError(
        'PARSE_ERROR',
        'レスポンスの解析に失敗しました',
        error.status,
        error
      );
    }
  }
  // ClientError の場合
  else if (error instanceof ClientError) {
    clientError = error;
  }
  // Error オブジェクトの場合
  else if (error instanceof Error) {
    clientError = new ClientError(
      'CLIENT_ERROR',
      error.message,
      undefined,
      error
    );
  }
  // ネットワークエラーの場合
  else if (error && typeof error === 'object' && 'name' in error) {
    const networkError = error as { name: string; message: string };
    if (networkError.name === 'TypeError' && networkError.message.includes('fetch')) {
      clientError = new ClientError(
        'NETWORK_ERROR',
        'ネットワークエラーが発生しました。インターネット接続を確認してください',
        0,
        error
      );
    } else {
      clientError = new ClientError(
        'UNKNOWN_ERROR',
        opts.fallbackMessage || '予期せぬエラーが発生しました',
        undefined,
        error
      );
    }
  }
  // その他の場合
  else {
    clientError = new ClientError(
      'UNKNOWN_ERROR',
      opts.fallbackMessage || '予期せぬエラーが発生しました',
      undefined,
      error
    );
  }
  
  // ログ出力
  if (opts.logError) {
    console.error('Client Error:', {
      code: clientError.code,
      message: clientError.message,
      statusCode: clientError.statusCode,
      originalError: clientError.originalError,
    });
  }
  
  // トースト通知
  if (opts.showToast) {
    toast.error(clientError.message);
  }
  
  // 認証エラーの場合のリダイレクト
  if (opts.redirectOnAuth && isAuthError(clientError.code)) {
    const currentUrl = window.location.pathname + window.location.search;
    const loginUrl = `/login?redirect=${encodeURIComponent(currentUrl)}`;
    window.location.href = loginUrl;
  }
  
  // カスタムエラーハンドラー
  if (opts.onError) {
    opts.onError(clientError);
  }
  
  return clientError;
}

// 認証エラーかどうかの判定
export function isAuthError(code: string): boolean {
  return [
    APIErrorCode.AUTHENTICATION_REQUIRED,
    APIErrorCode.INVALID_CREDENTIALS,
    APIErrorCode.TOKEN_EXPIRED,
    APIErrorCode.TOKEN_INVALID,
  ].includes(code as APIErrorCode);
}

// リトライ可能なエラーかどうかの判定
export function isRetryableError(error: ClientError): boolean {
  return [
    'NETWORK_ERROR',
    APIErrorCode.EXTERNAL_SERVICE_ERROR,
    APIErrorCode.DATABASE_ERROR,
    APIErrorCode.RATE_LIMIT_EXCEEDED,
  ].includes(error.code as any);
}

// フェッチラッパー（エラーハンドリング付き）
// export async function fetchWithErrorHandling(
//   url: string,
//   options: RequestInit = {},
//   errorOptions: ErrorHandlingOptions = {}
// ): Promise<Response> {
//   try {
//     const response = await fetch(url, options);
//     
//     if (!response.ok) {
//       throw response;
//     }
//     
//     return response;
//   } catch (error) {
//     const clientError = await handleClientError(error, errorOptions);
//     throw clientError;
//   }
// }

// リトライ機能付きフェッチ
export async function fetchWithRetry(
  url: string,
  options: RequestInit = {},
  maxRetries: number = 3,
  retryDelay: number = 1000,
  errorOptions: ErrorHandlingOptions = {}
): Promise<Response> {
  let lastError: ClientError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fetchWithErrorHandling(url, options, {
        ...errorOptions,
        showToast: attempt === maxRetries, // 最後の試行でのみトーストを表示
      });
    } catch (error) {
      lastError = error instanceof ClientError ? error : await handleClientError(error, errorOptions);
      
      // 最後の試行または リトライ不可能なエラーの場合は諦める
      if (attempt === maxRetries || !isRetryableError(lastError)) {
        break;
      }
      
      // 指数バックオフでリトライ
      const delay = retryDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}

// エラー復旧アクション
export const ErrorRecoveryActions = {
  // ページリロード
  reload: () => {
    window.location.reload();
  },
  
  // 前のページに戻る
  goBack: () => {
    window.history.back();
  },
  
  // ホームページに移動
  goHome: () => {
    window.location.href = '/';
  },
  
  // ログインページに移動
  goToLogin: (redirectUrl?: string) => {
    const redirect = redirectUrl || window.location.pathname + window.location.search;
    window.location.href = `/login?redirect=${encodeURIComponent(redirect)}`;
  },
};