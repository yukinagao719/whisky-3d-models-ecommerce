'use client';

import { fetchWithRetry, ErrorHandlingOptions } from './error-handler';

// API クライアントの設定
interface APIClientConfig {
  baseURL?: string;
  timeout?: number;
  maxRetries?: number;
  retryDelay?: number;
  defaultHeaders?: Record<string, string>;
}

// リクエストオプション
interface RequestOptions extends RequestInit {
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  errorHandling?: ErrorHandlingOptions;
}

// レスポンス型
// interface APIResponse<T = unknown> {
//   data?: T;
//   error?: string;
//   code?: string;
//   message?: string;
// }

export class APIClient {
  private baseURL: string;
  private timeout: number;
  private maxRetries: number;
  private retryDelay: number;
  private defaultHeaders: Record<string, string>;

  constructor(config: APIClientConfig = {}) {
    this.baseURL = config.baseURL || '';
    this.timeout = config.timeout || 30000; // 30秒
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 1000; // 1秒
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...config.defaultHeaders,
    };
  }

  // タイムアウト付きfetch
  private async fetchWithTimeout(
    url: string, 
    options: RequestInit = {}, 
    timeout: number
  ): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });
      return response;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  // メインリクエストメソッド
  private async request<T>(
    endpoint: string,
    options: RequestOptions = {}
  ): Promise<T> {
    const {
      // timeout = this.timeout,
      retries = this.maxRetries,
      retryDelay = this.retryDelay,
      errorHandling = {},
      headers,
      ...requestOptions
    } = options;

    const url = this.baseURL + endpoint;
    const requestHeaders = {
      ...this.defaultHeaders,
      ...headers,
    };

    const fetchOptions: RequestInit = {
      ...requestOptions,
      headers: requestHeaders,
    };

    try {
      const response = await fetchWithRetry(
        url,
        fetchOptions,
        retries,
        retryDelay,
        errorHandling
      );

      // レスポンスが空の場合
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        return {} as T;
      }

      const data = await response.json();
      return data;
    } catch (error) {
      // エラーハンドリングは fetchWithRetry で処理済み
      throw error;
    }
  }

  // HTTP メソッド
  async get<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'GET' });
  }

  async post<T>(
    endpoint: string, 
    data?: unknown, 
    options?: RequestOptions
  ): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async put<T>(
    endpoint: string, 
    data?: unknown, 
    options?: RequestOptions
  ): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async patch<T>(
    endpoint: string, 
    data?: unknown, 
    options?: RequestOptions
  ): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async delete<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }

  // ファイルアップロード
  async upload<T>(
    endpoint: string,
    file: File,
    options?: Omit<RequestOptions, 'headers'>
  ): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);

    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: formData,
      headers: {
        // Content-Type は自動設定されるため削除
        ...Object.fromEntries(
          Object.entries(this.defaultHeaders).filter(
            ([key]) => key.toLowerCase() !== 'content-type'
          )
        ),
      },
    });
  }
}

// デフォルトAPIクライアントインスタンス
export const apiClient = new APIClient();

// 認証付きAPIクライアント（セッション情報を自動で含める）
export const authApiClient = new APIClient({
  defaultHeaders: {
    'Content-Type': 'application/json',
  },
});

// 特定のAPI向けのクライアント
export const authAPI = {
  // 認証関連
  checkEmail: (email: string) =>
    authApiClient.post<{ exists: boolean }>('/api/auth/email/check', { email }),
  
  signup: (data: { name: string; email: string; password: string }) =>
    authApiClient.post<{ message: string }>('/api/auth/signup', data),
  
  verifyEmail: (token: string) =>
    authApiClient.post<{ message: string }>('/api/auth/email/verify', { token }),
  
  resetPassword: (email: string) =>
    authApiClient.post<{ message: string }>('/api/auth/password/reset', { email }),
  
  confirmPasswordReset: (token: string, password: string) =>
    authApiClient.post<{ message: string }>('/api/auth/password/confirm', { 
      token, 
      password 
    }),
};

export const accountAPI = {
  // アカウント管理
  updateProfile: (data: { name: string }) =>
    authApiClient.put<{ message: string }>('/api/account/update-profile', data),
  
  updateAvatar: (file: File) =>
    authApiClient.upload<{ imageUrl: string }>('/api/account/update-avatar', file),
  
  deleteAccount: () =>
    authApiClient.delete<{ message: string }>('/api/account/delete'),
};

export const purchaseAPI = {
  // 購入関連
  checkPurchases: (productIds: string[]) =>
    authApiClient.post<{ purchasedProductIds: string[] }>(
      '/api/purchases/check-multiple', 
      { productIds }
    ),
  
  getPurchaseHistory: () =>
    authApiClient.get<unknown[]>('/api/purchases'),
  
  createCheckout: (items: unknown[]) =>
    authApiClient.post<{ sessionId: string }>('/api/checkout', { items }),
  
  createPurchaseSession: (orderId: string) =>
    authApiClient.post<{ sessionId: string; downloadUrl: string }>(
      '/api/purchases/session',
      { orderId }
    ),
};

// ネットワーク状態監視
export class NetworkMonitor {
  private static instance: NetworkMonitor;
  private isOnline: boolean = navigator.onLine;
  private listeners: ((isOnline: boolean) => void)[] = [];

  private constructor() {
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
  }

  static getInstance(): NetworkMonitor {
    if (!NetworkMonitor.instance) {
      NetworkMonitor.instance = new NetworkMonitor();
    }
    return NetworkMonitor.instance;
  }

  private handleOnline = () => {
    this.isOnline = true;
    this.notifyListeners();
  };

  private handleOffline = () => {
    this.isOnline = false;
    this.notifyListeners();
  };

  private notifyListeners() {
    this.listeners.forEach(listener => listener(this.isOnline));
  }

  public getStatus(): boolean {
    return this.isOnline;
  }

  public subscribe(callback: (isOnline: boolean) => void): () => void {
    this.listeners.push(callback);
    // Unsubscribe function
    return () => {
      this.listeners = this.listeners.filter(listener => listener !== callback);
    };
  }

  public destroy() {
    window.removeEventListener('online', this.handleOnline);
    window.removeEventListener('offline', this.handleOffline);
    this.listeners = [];
  }
}

// ネットワーク状態フック（別ファイルに移動すべき）
// export function useNetworkStatus() {
//   const [isOnline, setIsOnline] = React.useState(true);

//   React.useEffect(() => {
//     const monitor = NetworkMonitor.getInstance();
//     setIsOnline(monitor.getStatus());

//     const unsubscribe = monitor.subscribe(setIsOnline);
//     return unsubscribe;
//   }, []);

//   return isOnline;
// }